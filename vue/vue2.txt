1. v-bind:title="message" 绑定信息
2. v-if="seen" 是否显示内容
3. v-for="todo in todos" for循环赋值
    console 中输入 app4.todos.push({ text: '新项目' })，会增加一个项
4. 
p>{{ message }}</p>
  <button v-on:click="reverseMessage">反转消息</button>    

  var app5 = new Vue({  
    el:'#app-5',
    data : {
      message : 'hello vue js'
    },

    methods:{
      reverseMessage : function(){
        this.message = this.message.split('').reverse().join('')
      }
    }
  })
通过方法来反转message的值
在方法中，data中的message的值通过 this.message来表示  

6. 
p>{{ message }}</p>
<input v-model="message">
v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定

8. Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

<div id="app-7">
  <ol>
    <!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    -->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
  </ol>
</div>
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})

9.  每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的
var vm = new Vue（{
    //选项
}）
10. 所有的Vue组件都是Vue实例
11. 当一个Vue实例被创建时，它将data对象中的所有property加入到Vue的响应式系统中，当这些property的值发生改变时，视图将会产生“响应”，即匹配更新为新值；
只有当实例被创建时就已经存在于data中的property才是响应式的，也就是说如果你添加一个新的property，不会触发响应

<div id="app-8">
  <p>{{a}}</p>
<p>{{b}}</p>
</div>

  var test = {a:1}
  var vm  = new Vue({
    el:'#app-8',
    data :  test
  })
  vm.a=2//会影响到数据
  test.a=3//也会影响到数据
  vm.b= 'hi'// 不会触发视图更新，没有初始化会报错，要在data中将其初始化后才可以（相当于在Vue初始化的时候加载进去了）
12. Object.freeze(obj) 会阻止修改现有的property，系统无法追踪变化
13.除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})

14. 每个Vue实例在被创建时都要经历一系列初始化过程，需要设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM等。同时会运行一些生命周期的钩子函数，这给了用户在不同阶段添加自己代码的机会

15. create 钩子，在一个实例被创建之后执行代码
new Vue({
    data:{a:1},
    created:function(){
        console.log('a is :'+ this.a)
    }
})
mounted : 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。
mounted 不会保证所有的子组件也都被挂载完成
mounted: function () {
  this.$nextTick(function () {
    // 仅在整个视图都被渲染之后才会运行的代码
  })
}

16. 
Mustache 语法 文本 : {{}}
原始HTML : v-html

17.Mustache 语法不能作用在 HTML attribute 上，这种情况应该使用 v-bind 指令
<div v-bind:id="dynamicId"></div>


18.JavaScript 表达式
{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}

19.<p v-if="seen">现在你看到我了</p>
这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素

20.v-bind 指令可以用于响应式地更新 HTML attribute：
<a v-bind:href="url">...</a>
在这里 href 是参数，告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定

21.v-on 监听DOM事件
<a v-on:click="doSomething">...</a>

22. 动态参数，动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定，任何其它非字符串类型的值都将会触发一个警告
<a v-bind:[attributeName]="url"> ... </a>
<a v-on:[eventName]="doSomething"> ... </a>
在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写

23. 修饰符 . 
.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：
<form v-on:submit.prevent="onSubmit">...</form>

24. 缩写
v-bind
<!-- 完整语法 -->
<a v-bind:href="url">...</a>
<!-- 缩写 -->
<a :href="url">...</a>
<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>

v-on
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>
<!-- 缩写 -->
<a @click="doSomething">...</a>
<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>

25. 可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新

26.我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。;
 如果你不希望有缓存，请用方法来替代

 27. 侦听器 watch


vuejs
new Vue({
    el:
    data:{}
    created:{}
    mounted:{}
    methods:{}
    computed:{}
    filters:{}//过滤器
    components:{}
})


 声明式编程，数据发生改变后，页面自动发生变化
 数据与页面分离
 1. 
 //let -- 变量 const -- 常量
 const app =  new Vue({})//传一个对象进去

 2. v-for 循环指令

 3. v-on 监听指令
 4. Vue中加 methodss
 5. this 代表当前的Vue对象，里面的值赋值用this
 6. Vue的options
 7. 生命周期 
 beforeCreated:function(){} //
 created:function(){} //
 mounted:function(){} //

 8. 模板创建设置

 9. 插值操作，data的值显示到HTML中 -- Mustache -- {{  }}，也可以写一些简单表达式
 10. v-once 元素和组件只渲染一次，不会随着数据改变而改变
 11. v-html  解析出html展示
 12. v-text 类似Mustache
 13. v-pre 不解析data直接显示
 14. v-cloak 在Vue解析之前，div中有一个属性，v-cloak；在Vue解析之后，div中没有这个v-cloak属性；用来控制样式的出现
 
 15. v-bind 属性值动态绑定 
 对象语法
 a. 缩写 ":"
 b. 动态绑定class属性 
对象语法 数组语法
c. 动态绑定style
对象语法 数组语法

16. 计算属性
computed
a. firstName+lastName
b. setter 和 getter
computed : {
    //简写
    fullName : function(){
        return this.firstName + ' ' + this.lastName
    }
    //完整写法
    fullName : {
        set : function(){ //计算属性，一般不用实现set方法，为只读属性
        },
        get : function(){
            return this.firstName + ' ' + this.lastName
        }
    }
}
c. 计算属性缓存，
拼接三种方法
1）直接html中计算
2）在methods中方法计算 -- 每次都重新计算，性能底
3)  在comouted中计算  -- 有缓存，性能高

17. ES6语法
1）var  不分块级作用域
let 块级作用域，且是变量
const 值不会再变的变量
es5 var 有闭包, 没闭包, es6 let

2）在ES6开发中，优先使用const，只有需要改变某一个标识符的时候才使用let
a. const 修饰的值不能修改，
b. const修饰的值必须赋值
c. 常量的含义是指向的对象不能修改，到那时可以改变对象内部的属性

3）对象的增强写法
//a. 属性的增强写法
const name = 'why';
const age = 18;
const height = 1.88;
//es5写法
const obj = {
    name : name,
    age : age,
    height : height
}
//es6写法
const obj = {
    name,
    age,
    height
}

//b. 函数的增强写法
//es5写法
const obj = {
    fun: function(){

    }
}
//es6写法
const obj = {
    fun(){

    }
}

18. 事件监听
1) v-on 
作用 绑定事件监听
缩写 @
预期 function | Inline Statement | Object 
--function如果不需要额外参数可以，不用加(),可以用增强写法
参数 event
2) 修饰符
@click.stop 调用event.stopPropagation() 不执行外层的click
@click.prevent 调用 event.preventDefault() 阻止默认事件
@click{.keyCode | .keyAlisa} 监听特定的键才触发回调  @keyup.enter = "keyup"
@click.native 监听组件根元素的原生事件
@click.once 只触发一次回调

19. v-if, v-else-if, v-else

20. for 属性

21. input复用，用key属性值是否相同来决定是否复用

22. v-show 是否要display某个元素 加一个style display:none 还存在于dom中就是不展示了
当要在显示与隐藏之间切换频繁的时候用v-show 当只有一次切换的时候用v-if

23. v-for 遍历数组 
a. v-for = "item in lists"
b. 遍历加上索引值 v-for = "(item,index) in lists"
c. 在遍历对象的过程中，如果值获取一个值，那么获取到的是value --  v-for = "item in info"
d. 获取key和value  -- v-for= "(value,key) in info"
e. 获取key value index  -- v-for = "(value,key,index) in info"

24. v-for使用过程 添加组件key的属性 --高效更新虚拟DOM
app.info.push() 在最后插入
app.info.splice(2,2) 删除元素
app.info.splice(2,0,'F')插入元素

25. 数组中哪些方法是响应式的
//1.push方法 -- 响应式
  this.letters.push('ggg')
//2.通过索引修改letters值 -- 非响应式
this.letters[0] = 'asdf'
//3. pop() -- 响应式
this.letters.pop()
//4. -- 响应式
this.letters.shift()
//5.unshifl可以加多个 -- 响应式
this.letters.unshifl('bbbb')
//6. -- 响应式 移除
this.letters.splice(2,0,'afv','f')

26. 对象的方式 后面可以跟bool值
:class="{active : isRed}"

27. 过滤器
{{变量 | 过滤器}} {{item.price | showPrice}}

28. button样式
<button @click="sub(index)" :disabled="item.count <=1">-</button>

29. js 高阶函数应用
a. 数组遍历
  for(let i = 0; i < this.bookLists.length;i++){
  for(let i in  this.bookLists){
  for(let book of  this.bookLists){
b. 
const nums = ['123','22','333','332','36']
1)取出所有小于100的数字
2)取出所有小于100的数字*2
let newNum = []
for(let n of nums){
  if(n < 100){
    newNum.push(n)
  }
}
c. 
1）filter  -- 回调函数必须返回一个bool值；
  当返回为true时，函数内部会自动将这次回调的n加入到新的数组中
  当返回为false时，函数内部会过滤掉这次的n
let newNums = nums.filter( function(n){ return n < 100} )

2）map -- 对数组中所有元素进行操作
let newNums = nums.map( function(n){ return n * 2} )

3）reduce -- 对数组中所有的内容进行汇总; preValue 上一次返回的值 ，n 传进去的值，0初始化值
let newNums = nums.map( function(preValue,n){ return preValue + n }, 0 )


29. v-model 表单绑定，实现表单元素和数据的双向绑定
原理：v-bind 绑定一个value属性，
     v-on给当前元素绑定input事件

<input type="text" v-model="message">
{{ message }}
<br>
<input type="text":value = "message" v-on:input= "valueChange">
{{ message }}
<br>
<input type="text":value = "message" v-on:input= "message = $event.target.value">
{{ message }}
valueChange(event){
    this.message = event.target.value
}

30. v-model 与radio结合使用
<label for="male">
    <input type="radio" id="male" value="男" v-model="sex">男
</label>
<label for="female">
    <input type="radio" id="female"  value="女" v-model="sex">女
</label>
<br>
<span>选择的性别是：{{ sex }}</span>

31. label for属性可以点击文字来选中里面的标签

32. v-model 与checkbox结合使用

33. v-model 与select
 
34. 值绑定 用循环方式设置checkbox

35.v-model修饰符
v-model.lazy input失焦点后再实时绑定
v-model.number input只允许输入数字
v-model.trim input内容出去空格

36. 组件化
一个个独立可以复用的组件来构造我们的应用
任何应用都会被抽象为一个组件树
 
37. 注册组件的基本步骤
1) 创建组件构造器 Vue.extend()
2) 注册组件    Vue.component()
3) 使用组件    在Vue实例作用范围内使用组件

38. 注册全局组件，局部组件（在对应的Vue中）
全局组件 -- 可以在多个Vue实例中使用
局部组件 -- 在对应的Vue中注册组件
components:{
  组件name: 组件构造器name
}

39. 
父组件：注册在Vue中
子组件：注册在父组件构造器中的compoents:{}中，在父构造器的template中使用子组件

40. 组件语法糖注册方式
省去了Vue.extend({})创造构造器的过程，直接在component中使用一个对象代替

41. 组件模板抽离写法
a.使用script标签 ，类型必须是type="text/x-template"
b. 使用<template id="cpn1"></template>

42. 组件中的数据存放
组件对象中也有存放数据的地方
1)组件里面不可以访问Vue实例里面的数据
2)组件的data必须是函数
//注册一个全局组件，使用data方法返回组件里面需要使用的数据
        Vue.component('cpn1',{
          template:'#cpn1',
          component:{
          },
          data(){
            return{
              title:'我是组件里面的标题啊'
            }
          },
          methods:{

          }
        })

44.组件中的data必须是函数，多个组件使用data中的数据，返回的是不同的对象

45.父子组件的通信
1）让大组件（父组件）将数据传递给小组件（子组件）
a. 通过props向子组件传递数据（props -- v-bind）
b. 通过事件向父组件发送消息($emit events -- v-on)

46.props基本用法
在组件中，使用选项props来声明需要从父级接收到的数据
props的值有两种方式
1）字符串数组，数组中的字符串就是传递时的名称
2）对象，对象可以设置传递时的类型，也可以设置默认值等

47.props通过v-bind来传递
v-bind:test="var" 用了v-bind 才能将var当变量将值传递给test，否则只能将字符串var传递给test.
通过v-bind,将父组件的值传递给子组件
<cpn1 v-bind:cmovies="movies" :cmessage="message">
然后在子组件中用props来接收

48.v-bind不支持驼峰 <cpn :c-info="info"></cpn>

49.使用v-on监听子组件的emit事件
子组件发送事件this.$emit('item-click',item)，父组件v-on监听 <cpn @item-click="cpnClick"></cpn>
btnClick(item){
        // 发送事件
        this.$emit('item-click',item)
      }

50.一但props中定义了属性，一定要通过父组件来改变值，不要用子组件直接改变，要在data中重新命名一个变量接收传过来的值，再改变重新命名的变量
components:{
  cpn:{
    template:'#cpn1',
    props:{
      number1:Number,
      number2:Number//由父组件进行修改，不赞成子组件直接修改
    },
    data(){
      return{
        dnumber1:this.number1,
        dnumber2:this.number2
      }
    }
  }
}

51.watch

52.父组件拿到子组件的对象，直接调用/修改子组件的属性/方法
53.父子组件的访问方式
1）父组件访问子组件：使用$children或$refs
2）子组件访问父组件：使用$parent
3）$root访问根组件

54.编译作用域，作用域插槽

55.es6模块化开发
1）导出 export 对象/变量/函数/类/default
export default 某些情况一个模块包含的某个功能，并不希望给这个功能命名，而且让导入者可以自己命名;
export default在同一个模块中，不允许同时存在多个
2）导入 import
统一导入 import * as aaa from './aaa.js'

56.webpack，将浏览器不能解析的文件模块化打包，让大部分浏览器可以解析
webpack将js/png/less/css开发的文件，模块化打包，最终生成一个文件夹，将文件夹放到服务器部署就行
现代的JavaScript应用的静态模块打包工具

57.webpack要正常工作，必须依赖node环境，
node环境为了可以正常执行很多代码，必须包含各种依赖的包，
安装node的时候自动安装一个npm工具，
npm(node packages manager)工具帮助管理node环境下各种包

58.
1）安装node.js
2）全局安装webpack(安装3.6.0 因为Vue cli2依赖该版本) npm install webpack@3.6.0 -g
Vue cli2可以看到webpack的各种配置，Vue cli3的话隐藏一起来
3）局部安装webpack（后续需要）
npm install webpack@3.6.0 --save-dev是开发时依赖，项目带包后不需要继续使用的
4）为什么在全局安装后，还要局部安装呢
在终端直接执行webpack命令，使用的是全局安装的webpack
当在package.json中定义script时，其中包含了webpack命令，那么使用的是局部webpack

59.
src 源码，开发的东西
dist打包后的东西，发布到服务器

60.开发的时候可以用common.es6等模块化开发思想，运行的时候使用webpack打包工具打包，就可以生成让浏览器试别的内容
webpack ./src/main.js ./dist/bundle.js 将main.js打包到bundle.js文件中；给一个入口文件打包即可，webpack会处理各个文件之间的依赖

61.webpack配置
1）用webpack.config.js，输出的路径用动态路径，const path = require('path') 导入node对应包中的模块path
2）npm init
   当前项目要装一些包，npm init 生成package.json文件，里面是项目相关的信息
3）npm install
   如果package.json中有依赖一些东西，则运行该命令时候会在当前文件安装一些东西
4）npm run build
   使用npm run build，不使用webpack命令了，将命令映射到package.json中的script中
"build": "webpack" //执行npm run build则会找到这个命令
且使用npm run build执行的webpack命令会优先使用本地的包，即不是全局安装的webpack，而是使用项目自己本地安装的webpack包，方便版本配合
5）npm install webpack@3.6.0 --save-dev
   项目安装本地webpack包 npm install webpack@3.6.0 --save-dev，在package.json中会多一个开发时依赖的webpack的包
 "devDependencies": {
     "webpack": "^3.6.0"
   }
6）开发时依赖：只有在开发时候才需要用到webpack，将代码打包，运行时候则不需要
运行时依赖:
7）devDependencies:{}开发时依赖
dependencies:{}运行时依赖
8）只要是在terminal中运行webpack则都是使用的全局命令，如果要使用局部的，则可以运行 node_module/.bin/webpack，
   或者在package.json中配置webpack则会优先找到本地的包

62.loader
1）是webpack的一个核心概念，webpack不支持将高级es6转为es5，将scss,less转为css,将.jsx.vue转为js等，则需要使用loader来转
2）loader的使用，
通过npm install --save-dev css-loader 安装loader;(cnpm install --save-dev css-loader@2.0.2)
在webpack.config.js中的modules关键字下进行配置
module: {
    rules: [
      {
        test: /\.css$/i,
        use: ["css-loader"],
      },
    ],
  }
如果打包不成功，也许是版本高低问题；
"css-loader" 只负责加载css文件，不负责生效css样式；

3）npm install style-loader --save-dev 将样式加载到到DOM页面(cnpm install style-loader@0.23.1 --save-dev)
再在webpack.config.js中的modules关键字下进行配置

4)use: ["style-loader","css-loader"], 使用多个loader时候，是从右向左使用

63.less-loader
64.url-loader
65.file-loader
66.label-loader es6打包时候转为es5

67.在webpack中配置vue，以.vue文件来组织
1）使用vue.js，则必然对其有些依赖，所以需要先安装（因为后续实际项目中也要使用vue，所以不是开发时依赖）
2）npm install vue --save (cnpm install vue@2.5.21 --save)
3）webpack.config.js中使用
resolve: {
    //alias别名
    alias: {
      'vue$':'vue/dist/vue.esm.js'
    }
  }
则使用Vue时用的是runtime-compiler,
4）SPA单页面复用，以后只有index.html文件，且只有<div id="app"></div>，多个页面的话，通过路由跳转
5）在Vue中定义template属性，则el与template关系是，
template中所有的东西在编译的时候，会复制到index.html中覆盖el的<div id="app"></div>这个内容

68.
1）Vue实例中template写很多代码不好，可以写一个组件
//1.方法一 直接在Vue实例中写template
//2.方法二 抽出模板
const Test = {
  template: `
    <div>
    <h2>{{ message }}</h2>
    <p>{{ name }}</p>
    </div>
  `,
  data() {
    return {
      message: 'hello webpack',
      name: 'gagaga'
    }
  },
  methods: {}

}
const app = new Vue({
  el: '#app',
  template: '<Test/>',
  components: {
    Test
  }
})
//3.方法三，创建app.js文件，直接在app.js文件中将App对象内容导出，再在main.js中导入使用即可
import App from './vue/app.js'
const app = new Vue({
  el: '#app',
  template: '<App/>',
  components: {
    App
  }
})
2）抽出的app.js文件中template与js代码混合没有分离，创建App.vue文件分离这些模块

69.加载解析.vue文件需要配置对应的loader，
1）安装 npm install vue-loader vue-template-compiler --save-dev (cnpm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev)
2）修改webpack.config.js文件
3）缺少插件(从vue-loader14版本开始需要安装插件)，解决方法：降低vue-loader版本（降低版本后，重新npm install），或安装插件

70. .vue文件的名称首字母大写

80.新建.vue文件，可以再其他.vue文件中导入，再注册使用
<script>
import Cpn from "./Cpn.vue";
export default {
  name: "App",
  components:{
    Cpn
  },
  data() {
    return {
      message: 'hello webpack',
      name: 'gagaga'
    }
  },
  methods: {
    btnClick(){
      console.log('click,,,,')
    }
  }
}
</script>

81.以后整个应用程序就是一个组件树，有一个根组件App.vue，然后开始引用其他组件，形成一个组件树

82.import vue文件时候要想省略掉.vue后缀，则可以再webpack.config.js文件中配置
 resolve: {
    //alias别名
    extensions:['vue'],//省略什么文件后缀则配置该文件
    alias: {
      'vue$':'vue/dist/vue.esm.js'
    }
  }

83.认识plugin:插件
1）webpack中的plugin，就是对webpack现有的功能的各种扩展，比如打包优化，文件压缩等
2）loader与plugin的区别
loader主要用于转换某些类型的模块，是一个转换器
plugin是插件，对webpack本身的扩展，是一个扩展器

84.plugin的使用过程
1）通过npm安装需要使用的plugins（某些webpack已经内置的插件不需要安装）
2）在webpack.config.js中配置plugins插件

85.版权协议，说明信息
1）导入
const webpack = require('webpack')
2）使用
plugins:[new webpack.BannerPlugin('最终版权归xxx所有')]

86.打包html的plugin，将html文件打包到dist文件夹下
1）htmlWebpackPlugin插件，自动生成一个index.html文件，将打包的js文件，自动通过script标签插入到body中
2）npm install html-webpack-plugin --save-dev 安装插件(npm install html-webpack-plugin@3.2.0 --save-dev)
3）使用插件，修改webpack.config.js文件中plugins内容
const HtmlWebpackPlugin = require('html-webpack-plugin')
 plugins:[
    new webpack.BannerPlugin('最终版权归xxx所有'),
    new HtmlWebpackPlugin({
          template:'index.html'
        })
  ]
4）可以注释掉webpack.config.js中output中publicPath路径

87.js压缩的plugin，开发阶段不适用，方便调试，发布时候可以加上
1）项目发布前要对js等文件进行压缩，使用第三方插件，uglifyjs-webpack-plugin，版本号指定1.1.1，和cli2保持一致
2）安装 npm install uglifyjs-webpack-plugin@1.1.1 --save-dev
3）修改webpack.config.js文件，使用插件
const UglifyjsWebpackPlugin = require('html-webpack-plugin')
plugins:[
    new webpack.BannerPlugin('最终版权归xxx所有'),
    new HtmlWebpackPlugin({
      template:'index.html'
    }),
    new UglifyjsWebpackPlugin()
  ]

88.webpack-dev-server 搭建本地服务器，webpack提供了一个可选的本地开发服务器，基于node.js搭建，内部使用express框架，可以实现浏览器自动刷新修改后的结果，开发时候使用，发布时候不使用
1）安装 npm install --save-dev webpack-dev-server@2.9.1
2）webpack.config.js中配置
3）项目跑起来，webpack-dev-server，可可以在webpack.config.js中配置简化语句，可以直接npm run dev，最后都测试好了再打包 npm run build
"dev": "webpack-dev-server"
"dev": "webpack-dev-server --open"直接打开浏览器

90.开发时使用，发布后使用的配置不同，可以做webpack配置分离
1）将webpack.config.js文件分为
base.config.js 共有东西
prod.config.js 生产的配置
dev.config.js 开发环境配置
最后在不同环境运行时候合并对应文件
2）合并，npm install webpack-merge --save-dev(4.1.5)
const webpackMerge = require('webpack-merge')
const baseConfig = require('./base.config')
module.exports = webpackMerge(baseConfig,{
    plugins:[
     new UglifyjsWebpackPlugin()
})

3）将package.json文件中的配置修改为
    "build": "webpack --config ./build/prod.config.js",
    "dev": "webpack-dev-server --open --config ./build/dev.config.js"
4）将base.config.js中文件打包后存放地址修改为path: path.resolve(__dirname, '../dist')

91.vue-cli脚手架工具自动生成webpack相关配置，快速搭建Vue开发环境以及对应的webpack配置

92.代码目录结构，项目结构，部署，热加载，代码单元测试等，可以通过脚手架帮助完成

93.Vue CLI使用依赖node
1）安装node.js，版本要在8.9以上
2）npm
3）安装Vue脚手架，安装全局即可 npm install -g @vue/cli （查看是否安装vue --version）
4）通过脚手架3的方式创建项目
5）如果还是想通过脚手架2的方式创建项目，则需要安装脚手架2相关模板 npm install -g @vue/cli-init

94.Vue CLI2初始化项目 vue init webpack my-project

95.Vue CLI3初始化项目 vue create my-project

96.
1）Runtime-Compiler
template-解析为-ast(抽象语法树)
-编译成render函数-render函数将template转为虚拟DOM树-渲染为真实的DOM
2）Runtime-only
render->虚拟DOM树->真实UI

3）Runtime-only性能更好，代码更少，

97.VUE程序运行过程
template-解析为-ast(抽象语法树)
-编译成render函数-render函数将template转为虚拟DOM树-渲染为真实的DOM

98.createElement()函数
render函数

99.Vue CLI3
基于webpack4打造
设计原则，0配置，一处配置文件根目录下的build和config文件
提供了vue ui 命令，提供了可视化配置
移除static文件，新增public文件夹，且将index.html移到public中

100.vue cli3创建项目
vue create 项目名称

101.
serve启动项目
build编译，最终打包时候运行

102.vue cli3最终看不到执行的哪个配置文件

103. el:'#app' 等同于 .$mount('#app')，el内部还是执行了mount方法

104.vue cli3的配置去哪里了，
启动配置服务器：命令行执行，vue ui
打开一个本地配置页面

105.vuecli3项目如果想要修改配置，需要在当前项目目录下面，创建文件，固定名称为vue.config.js

106.箭头函数基本使用
1）const aaa = function(){
}
2）const obj = {
bbb:function(){
},
bbb(){
}
}
3）箭头函数
const ccc = (参数列表)=>{
}
只有一个参数的时候
const ddd = (h) =>{
    return h*h
}
const ddd = h =>{
    return h*h
}
const ddd = h => h*h

107.将一个函数作为参数传到另外一个函数中时候，可以使用箭头函数，
箭头函数中的this中的使用：箭头函数中的this引用的就是最近作用域中的this

108.什么是路由
把信息从源地址传输到目的地址的活动
路由中有个非常重要的概率就是 路由表
路由本质就是一个映射表，决定的数据包的指向

109.
前端渲染
后端渲染
java代码从数据库中读取数据，并且将它动态的放在页面中
后端路由，后端处理url和页面之间的映射关系
前后端分离，后端只负责提供数据，不负责任何阶段的内容
前端路由，改变url但是页面不进行整体刷新

110.url的hash和html5的history
改变url但是页面不进行整体刷新，
方案一：改变url的hash，location.hash = 'aaaa',url会变，但是不会重新请求整体页面
方案二：改变html5的history(栈结构)，
a.history.pushState({},'','home'),history.back()移除一个
b.history.replaceState({},'','home')
c.history.go(-1) = history.back() //弹出一层
d.history.forward = history.go(1) //压入一个

110.安装使用vue-router
1）npm install vue-router --save
2）在模块化工程中使用它
a.创建router文件，在其中创建index.js配置路由信息
//0.配置路由相关信息，导入路由
import VueRouter from 'vue-router'
//1.通过Vue.use(插件)，安装插件
Vue.use(VueRouter)
//2.命名一个变量存放关系
const routes = [
]
//3.创建路由VueRouter对象
const router = new VueRouter({
  //4.配置路由和组件之间的关系
  routes
})
//5.将router对象传入到Vue实例中
export default router
//6.然后再在main.js中导入使用 import router from './router'，在Vue中使用

111.配置路由关系，且使用
1）创建路由组件（components文件中创建.vue文件）
2）配置路由映射：导入组件，在routes中配置组件和路径映射关系
import Home from "../components/Home";
import About from "../components/About";
const routes = [
  {
    path:'/home',//意味着只要路径里面出现了/home，则显示下面对应的组件
    component:Home
  },
  {
    path:'/about',
    component:About
  }
]
3）使用路由，通过<router-link>和<router-view>
<router-link>:vue-router的内置组件，最终会被渲染成为一个a标签
<router-view>：会根据当前的路径，动态渲染出路径对应的组件的内容

112.路由默认路径，重定向到home路径
{
    path:'/',
    redirect:'/home'
  }

113.页面路径修改为history模式
const router = new VueRouter({
  mode:'history',
  routes
})

114.router-link的其他属性补充
to属性，跳转到对应的页面
tag属性，将router-link渲染成对应的标签<router-link to="/home" tag="button">首页</router-link>
replace属性，增加replace属性后就无法返回了，内部默认使用了 history.replace();<router-link to="/home" tag="button" replace>首页</router-link>
active-class属性，<router-link to="/about" tag="button" active-class="active">
或者在router的js文件中配置加上active属性:linkActiveClass:'active'

115.通过代码跳转路由，不用router-link
vue-router给所有的组件都加了一个router属性，所以可以通过，this.$router拿到该属性
this.$router.push('/home') == history.pushState({},'','home')
this.$router.push('/about')
this.$router.replace('/home') == history.replaceState({},'','home')

this.$router是index.js中的router对象
this.$route是当前活跃的路由对象

116.动态路由
在某些情况下，一个页面的path路径可能是不确定的

117.vue-router 动态路由的使用
1）路由配置
{
    path:'/user/:userId',
    component:User
  }
2）组件中的使用
<router-link :to="'/user/'+userId">用户</router-link>
data(){
    return{
      userId:'gagaga'
    }
  }

118.获取链接中的data
computed:{
    userId(){
      return this.$route.params.userId
    }
  }

119.
打包文件的解析
业务代码 app
底层支撑 manifest
第三方 vendor

120.路由懒加载
const Home = () => import('../components/Home')

121.路由的嵌套
如在/home页面中，希望通过/home/news和/home/message访问一些内容
一个路径映射一个组件，访问这两个路径也会分别渲染两  个组件

122.实现路由嵌套
1）创建对应的子组件，并且在路由映射中配置对应的子路由
children: [
      {
        path: 'news',
        component: HomeNews
      },
      {
        path: 'message',
        component: HomeMessage
      }
    ]
2）在组件内部使用<router-view>标签
<router-link to="/home/news">新闻</router-link>
    <router-link to="/home/message">消息</router-link>
    <router-view></router-view>

123.ul>li{新闻$}*4

124.vue-router参数传递
<router-link :to="{path:'/profile',query:{name:'gagagad',age:18,address:'iiittt'}}">档案</router-link>
等价于 =》
<button @click="profileClick">档案</button>
this.$router.push({
        path:'/profile',
        query:{
          name:'gagapro',
          age:13,
          height:1.88
        }
      })
url链接上面就有query了
http://localhost:8080/profile?name=gagagad&age=18&address=iiittt
query  =  ?name=gagagad&age=18&address=iiittt
取出query值  <p>{{$route.query}}</p>

125.$router和$route区别

126.所有组件都继承自Vue的原型

127.导航守卫-在两个页面跳时候监听这个跳转动作，然后做一些操作
created(){} 一旦组件被创建就会调用该生命周期函数
mounted(){} 一旦组件的template内容都挂载到DOM里后，就会调用该函数
updated(){} 一旦页面发生了改变，更新，就会调用该函数

128.全局导航守卫，监听全局跳转
//前置守卫
router.beforeEach((to, from, next) => {
  //从from跳转到to
  document.title = to.matched[0].meta.title//to.meta.title
  next()
})
//后置钩子
router.afterEach((to, from)=>{
  //从from跳转到to
  document.title = to.matched[0].meta.title
})

129.meta元数据，描述数据的数据

130.路由独享守卫
在每个路由中配置，进入路由之前进行比较
{
    path: '/about',
    component: About,
    meta: {
      title: '关于'
    },
    beforeEnter: (to, from, next) => {
      next()
    }
  }

131.组件内的守卫
const Foo = {
}

132.keep-alive，组件内部的状态要保留，不想每次都创建新的组件要使用keep-alive，
keep-alive ：Vue的内置组件，可以使被包含的组件保留状态，或避免重新渲染
资料： https://www.jianshu.com/p/6363e089c321
keep-alive 才可以使用 activated/deactivated
首页中使用path属性记录离开时的路径，在beforeRouteLeave中记录

<keep-alive>
      <router-view></router-view>
</keep-alive>

133.项目

134.promise
异步编程的一种解决方案

135.Vue组件component命名
注册组件名	使用名	    结果
MyChild	   MyChild	    正确
MyChild	   My-Child	    正确
MyChild	   my-Child	    正确
MyChild	   My-child	    正确
MyChild	   my-child	    正确
MyChild	   My-Child	    正确
MyChild	   myChild	    正确
MyChild	   mychild	    错误
MyChild	   mY-Child	    错误

135.
1秒后再打印出内容
  setTimeout(()=>{
    const data = 'gagaga'
    console.log(data);

  },1000)

136.Promise参数是个函数，函数里有两个参数，resolve和reject，而这两个参数本身又是函数。
    网络请求和最终处理代码是分离的。调用resolve就会调用then，调用reject就会调用catch，同时将请求的结果传入then和catch。
new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('hello')
      reject('reject')
    }, 2000)
  }).then(data => {
    console.log(data);
  }).catch(error => {
    console.log(error);
  })

137.什么情况会用到promise
一般情况下有异步操作时，使用Promise对这个异步操作进行封装
一旦调用resolve,就会调用函数then()，如果还要调用，则可以再返回一个promise对象，如此一个链式编程

138.一步一步请求，return是结束then函数，返回一个新的Promise对象，后面接着可以再调then函数
  new Promise((resolve, reject)=>{
    setTimeout(()=>{
      const data = 'gagagaga'
      resolve(data)
    },1000)
  }).then((data)=>{
    console.log('第一步 hello')
    console.log(data)
    return new Promise((resolve, reject)=>{
      setTimeout(()=>{
        resolve()
      },1000)
    })
  }).then(()=>{
    console.log('第二步 hello')
    return new Promise((resolve, reject)=>{
      setTimeout(()=>{
        resolve()
      },1000)
    })
  }).then(()=>{
    console.log('第三步 hello')
  })

139.错误信息调用reject
new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('hello')
      reject('reject')
    }, 2000)
  }).then(data => {
    console.log(data);
  }).catch(error => {
    console.log(error);
  })

140.开发中有异步操作时，就可以给异步操作包装一个Promise
异步操作后有三种状态：
pending：等待状态，比如正在进行网络请求，或定时器没有到达时间
fulfill：满足状态，主动调用resolve时，就处于这个状态，并且回调.then()
reject：拒绝状态，当主动回调reject时，就处于该状态，并且回调.catch()

141.promise另外写法
new Promise((resolve, reject)=>{
  setTimeout(()=>{

    resolve('hello')
    reject('error')

  },1000)
}).then(data=>{
  console.log(data)
},err=>{
  console.log(err)
})

142.promise链式调用，逐步简写，且如果遇到reject方法，直接跳到最后catch，后面的.then不再执行
//网络请求 aaa 自己处理10行 传给下一步
  //将上一步结果 拼接一个111 自己处理10行 传给下一步
  //再将上一步结果 拼接222 自己处理10行 传给下一步

  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('aaa')
    }, 1000)
  }).then(data => {
    //1
    console.log('自己处理十行代码' + data)
    //2
    // return new Promise((resolve,reject) => {
    //   resolve(data + '111')
    //   // reject('reject')
    // })

    // return Promise.reject('reject简写')
    throw 'throw error message'
  }).then(data => {
    //3
    console.log('自己处理十行代码' + data)
    //4
    return new Promise(resolve => {
      resolve(data + '222')
    })
  }).then(data=>{
    //5
    console.log('自己处理十行代码' + data)
    //6
    return Promise.resolve(data+'333')
  }).then(data=>{
    //7
    console.log('自己处理十行代码' + data)

    //8
    return data+'444'
  }).then(data=>{
    console.log('自己处理十行代码' + data)
  }).catch(err=>{
    console.log(err)
  })

143.promise的all方法
网络请求一，网络请求二 都一起完成
$ajax()
$ajax()
//Promise.all等两个请求都完成了以后再执行.then方法
//results是一个数据，为上面两个请求返回的结果，results[0]是第一个promise的结果
Promise.all([
    new Promise((resolve, reject)=>{
      $ajax({
        url:'url1',
        success:function (data){
          resolve(data)
        }
      })
    }),
    new Promise((resolve, reject)=>{
      $ajax({
        url:'url2',
        success:function (data){
          resolve(data)
        }
      })
    }),
  ]).then(results=>{
    results[0]
    results[1]
  })
======
Promise.all([
    new Promise((resolve, reject)=>{
      setTimeout(()=>{
        resolve('2秒钟打印')
      },2000)
    }),
    new Promise((resolve, reject)=>{
      setTimeout(()=>{
        resolve('5秒钟打印')
      },5000)
    }),
  ]).then(results=>{
    console.log(results[0])
    console.log(results[1])
  })

144.Vuex概率和作用解析
1）之前我们学到过组件原型，所有的组件都继承自vue的原型，所以在原型上加一些东西，所有组件都能用，
Vue.prototype.XXX就可以实现多个组件拿到原型上的数据，但是它有个弊端，
它不像data被加入到vue的响应式系统中，我们自己定义的数据并不在响应式系统中，
所以当其中一个组件修改了原型上的数据值时，其他组件的这个数据并不会跟着一起改，
所以虽然这个方法能实现，但是不完善，由此我们就需要使用vuex。
2）vuex是专为vue.js应用程序开发的状态管理模式
集中式存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变
把需要多个组件共享的变量全部存储在一个对象里面
然后将这个对象放在顶层Vue实例中，让其他组件可以使用，则多个组件就可以共享这个对象中所有的变量属性了
该Vuex插件是响应式的，一个组件改变了值以后，其他组件可以知道

145.管理什么状态呢，什么状态需要在组件间共享
登录状态，用户名称，头像，地理位置
商品的收藏，购物车中的物品





一、父组件向子组件传
1. 父组件向子组件传值 静态
<子组件名称 :子组件接收变量名 = 值 />
子组件中用 props接收变量名获取值

2. 父组件向子组件传值 动态（根据父组件中值的变化，动态改变子组件中的值）
父组件：
<template>
  <div>
    <input type="text" v-model="hello">
    <Cpn :message="hello"></Cpn>
  </div>
</template>
子组件：
<template>
  <div>
    <p>{{message}}</p>
  </div>
</template>
props:["message"]

3. v-model 另外写法
方法总结：
1.子组件设 value 为props属性，并且不主动改变 value 值
2.子组件通过 this.$emit('input', 'updateValue') 将 updateValue 值传给父组件
3.父组件通过 v-model="localValue" 绑定一个本地变量，即可实现子组件value值与父组件updateValue 值同步更新

1）v-model  
<input v-model="sth">
等价于
<input v-bind:value="ssh" v-on:input="sth = $event.target.value">
等价于
<input :value="ssh" @input="sth = $event.target.value">
解释：每当输入框内容发生变化时，就会触发oninput，把最新的value传递给 sth
v-model 不仅仅能在 input上用，在组件上也能使用
子组件向父组件传值通过this.$emit('input',data），父组件通过@input来接收

当有数据输入时触发了该组件的input事件
手动触发父组件的input事件并将值传给父组件
父组件的input事件被触发，将传来的值赋给父组件的变量price，实现输入框value到父元素的price的单向绑定
父组件value的值绑定到price 
将父组件的value值通过props传递给子组件，实现了父组件的price到子组件value的单向绑定

v-bind只能实现单向绑定
v-model（v-bind+触发的input事件）实现双向绑定


二、子组件向父组件传
4. ref实现页面传值
静态：
父组件中
<子组件名称  ref="名称">
this.$ref['名称'].子组件方法

5.$emit方法实现通信，子组件主动触发事件将数据传递给父组件
子组件中
<template>
  <div>
    <Tree :data='treeData' show-checkbox ref='treeData'>
    <button type='success' @click='submit'></buttom>
  </div>
</template>
<script>
  submit(){
    this.$emit('getTreeData', this.$refs.treeData.getCheckedNode())
  }
</script>

父组件中
<AuthTree @getTreeData='testData'/>
<script>
  testData(){
    
  }
</script>

三、关于修改值
1.父组件传给子组件值，props接收时
在vue中,父组件向子组件传值, 并在子组件改变了父组件的值,就会发出警告
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：
父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态;
每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。
这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

解决办法:
在子组件中再写个方法 把穿过来的值更新给父组件,父组件再接收这个值,然后赋值给要传递的值上面

2. v-model
如果你想父组件改变model，自组件能实时接到，子组件去watch这个model。
如果你想子组件改变model，同步给父组件，那么你在改子组件model的时候，绑定this.$emit("model",model)
父组件@model="modelFunc",modelFunc类似于function，去接收就好了


